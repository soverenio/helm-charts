# HTTPS Proxy URL
httpsProxy: ""
httpsProxyNoProxy: ""
useExternalSecrets: false

crawler:
  deploymentAnnotations: {}
  deploymentLabels: {}
  podAnnotations: {}
  podLabels: {}
  token: ""
  image:
    name: soveren/crawler
    tag: v0.12.1
    pullPolicy: IfNotPresent
  env: []
  priorityClassName: ""
  resources:
    requests:
      cpu: "100m"
      memory: "100Mi"
    limits:
      cpu: "1500m"
      memory: "768Mi"
      ephemeral-storage: 100Mi
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
  nodeSelector: {}
  affinity: {}
  tolerations: []
  imagePullSecrets: []
  service:
    annotations: {}
    labels: {}
    port: 9000
  cfg:
    log:
      level: error
    s3:
      enabled: false
      # S3 storage URL, including schema. Leave empty for AWS
      url: ""
      # S3 security token service URL, including schema. Leave empty for AWS
      # For MinIO, leave it blank or set equal to url (see above)
      stsurl: ""
      # S3 storage type. Acceptable values: aws, yandexcloud, minio
      #
      # WARNING!
      # A separate DAR sensor must be deployed for each S3 implementation, such as AWS or MinIO.
      #
      type: "aws"
      # Access key ID
      accessKeyId: ""
      # Secret access key
      secretAccessKey: ""
      # Interval between checking if the bucket info is updated
      checkinterval: "12h"
      # Max number of attempts for retrying requests to the storage
      retrymaxattempts: 5
      # Max delay before the next retry request to the storage
      retrymaxbackoffdelay: "20s"
      # Folder ID. Relevant only for Yandex Cloud
      # If left blank, there will be no links to the cloud console available in the UI
      folderid: ""
      # Fully Qualified Domain Name (FQDN) self-hosted s3 service console URL (including schema).
      # If empty, links to self-hosted console won't be available
      consoleurl: ""
      # Fully Qualified Domain Name (FQDN) for self-hosted s3 service domain (including schema).
      # If empty, connections from assets to self-hosted s3 won't be found
      bucketsdomain: ""
      # Set false if AWS is used, otherwise true
      # If true, get owner info from the buckets list; if false, use separate API to get info about the current AWS user
      getbucketownerfromlist: false
      s3role:
        # Role to assume when accessing the storage
        enabled: false
        # The Amazon Resource Name (ARN) of the role to assume.
        rolearn: ""
        # An identifier for the assumed role session.
        rolesessionname: SoverenCrawlerSession
        # The duration of the role session
        # Min: 15 minutes
        # Max: max session duration set for the role in the IAM. If you specify a value higher than that, the operation fails
        duration: 15m0s
        # Access policy
        policy: ""
      # Yandex Cloud parameters needed for correctly inferring the public/non-public status of buckets
      yandexcloud:
        # The private key obtained when creating authorized keys for provided service account
        # Example:
        # privatekey: |-
        #   PLEASE DO NOT REMOVE THIS LINE!
        #   -----BEGIN PRIVATE KEY-----
        #   ...
        #   -----END PRIVATE KEY-----
        privatekey: ""
        # ID of the public key obtained when creating authorized keys for provided service account
        publickeyid: ""
        # Service account ID that the IAM token will be requested for.
        # This service account must have the iam.serviceAccounts.tokenCreator role
        serviceaccountid: ""
      clienttlsconfig:
        # Skip tls certificate verification for self-hosted s3 service
        insecureskipverify: false
    kafka:
      enabled: false
    database:
      checkinterval: "24h"
      postgres:
        enabled: false
      mssql:
        enabled: false
      mysql:
        enabled: false

prometheusAgent:
  enabled: true
  deploymentAnnotations: {}
  deploymentLabels: {}
  podAnnotations: {}
  podLabels: {}
  additionalMetrics:
    enabled: false
    name: client
    url: http://prometheus.prometheus:9100/metrics/send
  image:
    name: prom/prometheus
    tag: v2.37.0
    pullPolicy: IfNotPresent
  env: []
  priorityClassName: ""
  resources: 
    requests:
      memory: "192Mi"
      cpu: "75m"
    limits:
      memory: "400Mi"
      cpu: "75m"
      ephemeral-storage: 100Mi
  securityContext:
    runAsUser: 65534
    runAsNonRoot: true
    runAsGroup: 65534
    allowPrivilegeEscalation: false
  nodeSelector: {}
  affinity: {}
  tolerations: []
  imagePullSecrets: []
  cfg:
    log:
      level: error

detectionTool:
  deploymentAnnotations: {}
  deploymentLabels: {}
  podAnnotations: {}
  podLabels: {}
  image:
    name: soveren/detection-tool-dar
    tag: v2.12.6
    pullPolicy: IfNotPresent
  env: []
  priorityClassName: ""
  resources:
    requests:
      cpu: "200m"
      memory: "2252Mi"
    limits:
      cpu: "2200m"
      memory: "4000Mi"
      ephemeral-storage: 200Mi
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    allowPrivilegeEscalation: false
    runAsNonRoot: true
  nodeSelector: {}
  affinity: {}
  tolerations: []
  imagePullSecrets: []
  metricsPort: 9100
  service:
    annotations: {}
    labels: {}
    port: 8000
  cfg:
    log:
      kafkaEnabled: true
      level: error

kafka:
  topics:
#    controlRequestTopicName: control_request
    logsTopicName: logs
  embedded:
    enabled: true
    deploymentAnnotations: {}
    deploymentLabels: {}
    podAnnotations: {}
    podLabels: {}
    image:
      name: soveren/kafka
      tag: 2.13-3.5.1
      pullPolicy: IfNotPresent
    env:
      - name: KAFKA_HEAP_OPTS
        value: -Xmx512m -Xms512m
    priorityClassName: ""
    resources:
      requests:
        cpu: "100m"
        memory: "650Mi"
        ephemeral-storage: 5Gi
      limits:
        cpu: "400m"
        memory: "1024Mi"
        ephemeral-storage: 10Gi
    securityContext:
      runAsUser: 1000
      runAsGroup: 1000
      runAsNonRoot: true
      fsGroup: 1000
    nodeSelector: {}
    affinity: {}
    tolerations: []
    imagePullSecrets: []
    persistentVolume:
      # -- Create/use Persistent Volume Claim for server component. Empty dir if false
      enabled: false
      # -- Array of access modes. Must match those of existing PV or dynamic provisioner. Ref: [http://kubernetes.io/docs/user-guide/persistent-volumes/](http://kubernetes.io/docs/user-guide/persistent-volumes/)
      accessModes:
        - ReadWriteOnce
      annotations: {}
      # -- StorageClass to use for persistent volume.
      storageClass: ""
      # -- Bind Persistent Volume by labels. Must match all labels of targeted PV.
      matchLabels: {}
      # -- Size of the volume. Should be calculated based on the metrics you send and retention policy you set.
      size: 10Gi
    service:
      annotations: {}
      labels: {}
      port: 9092
    metrics:
      enabled: true
      port: 9308
      image:
        name: soveren/kafka-exporter
        tag: v1.7.0
      resources:
        requests:
          cpu: "100m"
          memory: "650Mi"
          ephemeral-storage: 5Gi
        limits:
          cpu: "400m"
          memory: "1024Mi"
          ephemeral-storage: 10Gi
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        allowPrivilegeEscalation: false
        runAsNonRoot: true
  external:
    # kafka.external.brokers used only if kafka.embedded.enabled=false
    brokers: []

networkPolicy:
  # -- Specifies whether Network Policies should be created
  enabled: false
  # -- Specify IP or IP/MASK when the httpsProxy is enabled
  proxyIp: ""
  # -- Specify IP/MASK, PORT, PROTOCOL for additional IP whitelist egress
  #  crawlerAdditionalEgress:
  #      - name: postgres
  #        host: 192.168.1.1/32
  #        port: 5432
  #        protocol: TCP
  crawlerAdditionalEgress: []
